# Code generation

As there are a ton of options and fields available in the Pulsar Admin API it was decided to generate CRDs and models from the swagger definitions from Pulsar.

> **Note**
>
> After editing anything in `apis/` you should run `make codegen` to update the CRDs and models for the operator.
>
> Dependencies for code generation are in `dev-requirements.txt`.

## CRDs

The entrypoint for CRDs is in `apis/`. Each CRD references a `version` object in multiple API versions (`v1alpha1`, `v1beta1`, `v1`, ..) as is standard with CRDs. `$ref` is used to reference objects across YAML files which is de-referenced using a python script (`scripts/crdgen.py`) and written to `crds/`.

This way is simple to build these CRDs by hand while being able to reference re-usable objects (even from external definitions).

### Example

`apis/neuronnamespace.yaml`
```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: neuronconnections.neuron.isf
spec:
  group: neuron.isf
  names:
    kind: NeuronConnection
    plural: neuronconnections
    singular: neuronconnection
  scope: Namespaced
  versions:
  - $ref: v1alpha1/neuronconnection.yaml#/version
```

`apis/v1alpha1/neuronconnection.yaml`
```yaml
version:
  name: v1alpha1
  subresources:
    status: {}
  schema:
    openAPIV3Schema:
      type: object
      required:
        - spec
      properties:
        spec:
          $ref: '#/definitions/ConnectionSpec'
        status:
          $ref: '#/definitions/ConnectionStatus'

definitions:
  ConnectionSpec:
    ...
  ConnectionStatus:
    ...
```

which will be rendered as

`crds/neuronconnection.yaml`
```yaml
# auto-generated by crdgen.py
# any changes will be over-written!
# source of truth is in neuron-operator-application/apis
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: neuronconnections.neuron.isf
spec:
  group: neuron.isf
  names:
    kind: NeuronConnection
    plural: neuronconnections
    singular: neuronconnection
  scope: Namespaced
  versions:
  - name: v1alpha1
    schema:
      openAPIV3Schema:
        properties:
          spec:
            properties:
              namespace:
                description: The Namespace of the serivce that should be used for
                  Pulsar API communication
                title: Namespace
                type: string
              override:
                description: Optional override to set a full URL of Pulsar API instead
                  of building from service+namespace
                title: Override
                type: string
              port:
                default: 80
                description: The port that should be used for Pulsar API communication
                title: Port
                type: integer
              secure:
                default: true
                description: If set to 'true' https will be used, otherwise http
                title: Secure
                type: boolean
              service:
                description: Name of the service that should be used for Pulsar API
                  communication
                title: Service
                type: string
            required:
            - service
            type: object
          status:
            default:
              conditions: []
              phase: Pending
            properties:
              clusters:
                description: List of discovered clusters
                items:
                  type: string
                title: Clusters
                type: array
              conditions:
                default: []
                description: List of condition checks
                items:
                  properties:
                    message:
                      description: Message for a failed status check
                      type: string
                    reason:
                      description: Reason for a failed status check
                      type: string
                    status:
                      description: Status of condition check
                      type: string
                    type:
                      description: Type of condition check
                      type: string
                  required:
                  - type
                  - status
                  type: object
                title: Conditions
                type: array
              observedGeneration:
                description: Last observed generation of resource
                type: integer
              phase:
                description: The phase of the resource
                title: Phase
                type: string
              topicLevelPoliciesEnabled:
                description: Topic level policies enabled in broker
                title: Topiclevelpoliciesenabled
                type: boolean
              url:
                description: The generated URL
                title: Url
                type: string
            required:
            - phase
            type: object
        required:
        - spec
        type: object
    served: true
    storage: true
    subresources:
      status: {}
```

Some CRDs reference definitions from the official Pulsar swagger definitions. This is done so it's not require to add every single available field manually.

However, some fields (especially in the namespace policies) are snake_case which doesn't fit the style of Kubernetes CRDs which is camelCase. Therefor all properties in snake_case are automatically converted to camelCase in the final CRD.

## Models

`datamodel-code-generator` is used to take the selected JSON schemas from the Pulsar swagger definitions and create pydantic models to be used by the operator when interacting with both Kubernetes objects and the Pulsar REST API. This automatically takes care of mapping the modified snake_case to camelCase fields back to its original form where necessary. The logic lives in `scripts/modelgen.py`.

This script goes1through all YAML files in a selected version folder (for example `v1alpha1`) and merges them together, then all external `$ref` are copied over and made internal in `.definitions`. After that all keys in `.overrides` are merged on-top of those `.definitions` objects. This is done so that it's possible to overlay some data on-top of definitions that come from the external Pulsar swagger definitions (namely to specify which URI and method is used to update a single policy in namespaces).

### Example

`v1alpha1/common.yaml`
```yaml
definitions:
  NamespacePolicies:
    # Instructs our script to resolve this ref in-place
    # before passing it to the code generator
    resolve: true
    $ref: '2.9.2.json#/definitions/Policies'

overrides:
  NamespacePolicies:
    auth_policies:
      immutable: true
    # ...
    retention_policies:
      uri: /retention
    # ...
    schema_compatibility_strategy:
      method: PUT
```

src/models/out.py
```python
class NamespacePolicies(BaseModel):
    authPolicies: Optional[AuthPolicies] = Field(
        None, alias="auth_policies", immutable=True
    )
    retentionPolicies: Optional[RetentionPolicies] = Field(
        None, alias="retention_policies", uri="/retention"
    )
    schemaCompatibilityStrategy: Optional[SchemaCompatibilityStrategy] = Field(
        None, alias="schema_compatibility_strategy", method="PUT"
    )
    # ...
```

These models are then overlaid further in python using class inheritance and mixin classes to use the `uri`, `method` and `immutable` options for building API requests to the Pulsar REST API.
