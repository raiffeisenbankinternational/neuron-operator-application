# generated by datamodel-codegen:
#   filename:  <stdin>
#   timestamp: 2022-10-27T08:40:17+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Model(BaseModel):
    class Config:
        allow_population_by_field_name = True

    __root__: Any


class Type(str, Enum):
    AVRO = "AVRO"
    JSON = "JSON"


class Type1(str, Enum):
    record = "record"


class Schema(BaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., alias="name", description="Name of the schema")
    type: Type1 = Field(
        ...,
        alias="type",
        description="Schema type (currently only record is supported)",
    )
    doc: Optional[str] = Field(
        None, alias="doc", description="Description to add to the schema"
    )
    namespace: Optional[str] = Field(
        None, alias="namespace", description="Namespace of the schema"
    )
    fields: List[Dict[str, Any]] = Field(
        ..., alias="fields", description="List of fields in the schema"
    )


class NeuronClusterName(BaseModel):
    class Config:
        allow_population_by_field_name = True

    __root__: str = Field(
        ...,
        description="The name of the Neuron cluster the resource should be deployed to.",
    )


class LifecyclePolicy(str, Enum):
    KeepAfterDeletion = "KeepAfterDeletion"
    CleanUpAfterDeletion = "CleanUpAfterDeletion"


class StatusCondition(BaseModel):
    class Config:
        allow_population_by_field_name = True

    reason: Optional[str] = Field(
        None, alias="reason", description="Reason for a failed status check"
    )
    status: str = Field(..., alias="status", description="Status of condition check")
    type: str = Field(..., alias="type", description="Type of condition check")
    message: Optional[str] = Field(
        None, alias="message", description="Message for a failed status check"
    )


class Status(BaseModel):
    class Config:
        allow_population_by_field_name = True

    conditions: Optional[List[StatusCondition]] = Field(
        [], alias="conditions", description="List of condition checks"
    )
    observedGeneration: Optional[int] = Field(
        None, description="Last observed generation of resource"
    )
    connectionURL: Optional[str] = Field(
        None, description="URL from the NeuronConnection referenced by ConnectionRef"
    )
    phase: str = Field(..., alias="phase", description="The phase of the resource")


class TenantSettings(BaseModel):
    class Config:
        allow_population_by_field_name = True

    adminRoles: Optional[List[str]] = Field(
        None,
        description="Comma separated list of auth principal allowed to administrate the tenant.",
    )
    allowedClusters: Optional[List[str]] = Field(
        None, description="Comma separated allowed clusters."
    )


class SubscriptionAuthMode(str, Enum):
    None_ = "None"
    Prefix = "Prefix"


class SchemaAutoUpdateCompatibilityStrategy(str, Enum):
    AutoUpdateDisabled = "AutoUpdateDisabled"
    Backward = "Backward"
    Forward = "Forward"
    Full = "Full"
    AlwaysCompatible = "AlwaysCompatible"
    BackwardTransitive = "BackwardTransitive"
    ForwardTransitive = "ForwardTransitive"
    FullTransitive = "FullTransitive"


class SchemaCompatibilityStrategy(str, Enum):
    UNDEFINED = "UNDEFINED"
    ALWAYS_INCOMPATIBLE = "ALWAYS_INCOMPATIBLE"
    ALWAYS_COMPATIBLE = "ALWAYS_COMPATIBLE"
    BACKWARD = "BACKWARD"
    FORWARD = "FORWARD"
    FULL = "FULL"
    BACKWARD_TRANSITIVE = "BACKWARD_TRANSITIVE"
    FORWARD_TRANSITIVE = "FORWARD_TRANSITIVE"
    FULL_TRANSITIVE = "FULL_TRANSITIVE"


class RolePermissionEnum(str, Enum):
    produce = "produce"
    consume = "consume"
    functions = "functions"
    sources = "sources"
    sinks = "sinks"
    packages = "packages"


class TenantSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    tenant: str = Field(..., alias="tenant", description="Name of the tenant")
    neuronClusterName: Optional[NeuronClusterName] = None
    lifecyclePolicy: Optional[LifecyclePolicy] = "KeepAfterDeletion"
    settings: Optional[TenantSettings] = Field(None, alias="settings")


class InactiveTopicDeleteMode(str, Enum):
    delete_when_no_subscriptions = "delete_when_no_subscriptions"
    delete_when_subscriptions_caught_up = "delete_when_subscriptions_caught_up"


class InactiveTopicPolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    inactiveTopicDeleteMode: Optional[InactiveTopicDeleteMode] = None
    maxInactiveDurationSeconds: Optional[int] = None
    deleteWhileInactive: Optional[bool] = None


class RetentionPolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    retentionTimeInMinutes: Optional[int] = None
    retentionSizeInMB: Optional[int] = None


class PersistencePolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    bookkeeperEnsemble: Optional[int] = None
    bookkeeperWriteQuorum: Optional[int] = None
    bookkeeperAckQuorum: Optional[int] = None
    managedLedgerMaxMarkDeleteRate: Optional[float] = None


class AuthPolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    topicAuthentication: Optional[Dict[str, Dict[str, List[RolePermissionEnum]]]] = None
    namespaceAuthentication: Optional[Dict[str, List[RolePermissionEnum]]] = None
    subscriptionAuthentication: Optional[Dict[str, List[str]]] = None


class BundlesData(BaseModel):
    class Config:
        allow_population_by_field_name = True

    boundaries: Optional[List[str]] = Field(None, alias="boundaries")
    numBundles: Optional[int] = None


class Policy(str, Enum):
    producer_request_hold = "producer_request_hold"
    producer_exception = "producer_exception"
    consumer_backlog_eviction = "consumer_backlog_eviction"


class BacklogQuota(BaseModel):
    class Config:
        allow_population_by_field_name = True

    limitSize: Optional[int] = None
    limitTime: Optional[int] = None
    policy: Optional[Policy] = Field(None, alias="policy")
    limit: Optional[int] = Field(None, alias="limit")


class DispatchRateImpl(BaseModel):
    class Config:
        allow_population_by_field_name = True

    dispatchThrottlingRateInMsg: Optional[int] = None
    dispatchThrottlingRateInByte: Optional[int] = None
    relativeToPublishRate: Optional[bool] = None
    ratePeriodInSecond: Optional[int] = None


class SubscribeRate(BaseModel):
    class Config:
        allow_population_by_field_name = True

    subscribeThrottlingRatePerConsumer: Optional[int] = None
    ratePeriodInSecond: Optional[int] = None


class AutoTopicCreationOverride(BaseModel):
    class Config:
        allow_population_by_field_name = True

    defaultNumPartitions: Optional[int] = None
    allowAutoTopicCreation: Optional[bool] = None
    topicType: Optional[str] = None


class AutoSubscriptionCreationOverride(BaseModel):
    class Config:
        allow_population_by_field_name = True

    allowAutoSubscriptionCreation: Optional[bool] = None


class PublishRate(BaseModel):
    class Config:
        allow_population_by_field_name = True

    publishThrottlingRateInMsg: Optional[int] = None
    publishThrottlingRateInByte: Optional[int] = None


class DelayedDeliveryPolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    tickTime: Optional[int] = None
    active: Optional[bool] = Field(None, alias="active")


class ManagedLedgerOffloadedReadPriority(str, Enum):
    BOOKKEEPER_FIRST = "BOOKKEEPER_FIRST"
    TIERED_STORAGE_FIRST = "TIERED_STORAGE_FIRST"


class OffloadPolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    fileSystemProfilePath: Optional[str] = None
    fileSystemURI: Optional[str] = None
    offloadersDirectory: Optional[str] = None
    managedLedgerOffloadThresholdInBytes: Optional[int] = None
    managedLedgerOffloadDeletionLagInMillis: Optional[int] = None
    managedLedgerOffloadedReadPriority: Optional[
        ManagedLedgerOffloadedReadPriority
    ] = None
    s3ManagedLedgerOffloadRegion: Optional[str] = None
    s3ManagedLedgerOffloadBucket: Optional[str] = None
    s3ManagedLedgerOffloadServiceEndpoint: Optional[str] = None
    s3ManagedLedgerOffloadCredentialId: Optional[str] = None
    s3ManagedLedgerOffloadCredentialSecret: Optional[str] = None
    s3ManagedLedgerOffloadRole: Optional[str] = None
    s3ManagedLedgerOffloadRoleSessionName: Optional[str] = None
    gcsManagedLedgerOffloadRegion: Optional[str] = None
    gcsManagedLedgerOffloadBucket: Optional[str] = None
    managedLedgerOffloadBucket: Optional[str] = None
    managedLedgerOffloadRegion: Optional[str] = None
    managedLedgerOffloadServiceEndpoint: Optional[str] = None
    managedLedgerOffloadMaxBlockSizeInBytes: Optional[int] = None
    managedLedgerOffloadDriver: Optional[str] = None
    managedLedgerOffloadMaxThreads: Optional[int] = None
    managedLedgerOffloadPrefetchRounds: Optional[int] = None
    s3ManagedLedgerOffloadMaxBlockSizeInBytes: Optional[int] = None
    s3ManagedLedgerOffloadReadBufferSizeInBytes: Optional[int] = None
    gcsManagedLedgerOffloadMaxBlockSizeInBytes: Optional[int] = None
    gcsManagedLedgerOffloadReadBufferSizeInBytes: Optional[int] = None
    gcsManagedLedgerOffloadServiceAccountKeyFile: Optional[str] = None
    managedLedgerOffloadReadBufferSizeInBytes: Optional[int] = None


class SchemaSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    tenant: str = Field(
        ..., alias="tenant", description="Name of the tenant the topic belongs to"
    )
    namespace: str = Field(
        ..., alias="namespace", description="Name of the namespace the topic belongs to"
    )
    topic: str = Field(
        ..., alias="topic", description="Name of the topic the schema should belong to"
    )
    neuronClusterName: Optional[NeuronClusterName] = None
    lifecyclePolicy: Optional[LifecyclePolicy] = "KeepAfterDeletion"
    type: Optional[Type] = Field(
        "AVRO", alias="type", description="The schema serialization type"
    )
    schema_: Schema = Field(..., alias="schema", description="The schema definition")
    properties: Optional[Dict[str, Any]] = Field(
        None, alias="properties", description="Extra properties to add to schema"
    )


class NamespacePolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    authPolicies: Optional[AuthPolicies] = Field(
        None, alias="auth_policies", immutable=True
    )
    replicationClusters: Optional[List[str]] = Field(
        None, alias="replication_clusters", uri="/replication"
    )
    bundles: Optional[BundlesData] = Field(None, alias="bundles", immutable=True)
    backlogQuotaMap: Optional[Dict[str, BacklogQuota]] = Field(
        None, alias="backlog_quota_map", immutable=True
    )
    clusterDispatchRate: Optional[Dict[str, DispatchRateImpl]] = Field(
        None, uri="/dispatchRate"
    )
    topicDispatchRate: Optional[Dict[str, DispatchRateImpl]] = None
    subscriptionDispatchRate: Optional[Dict[str, DispatchRateImpl]] = None
    replicatorDispatchRate: Optional[Dict[str, DispatchRateImpl]] = None
    clusterSubscribeRate: Optional[Dict[str, SubscribeRate]] = Field(
        None, uri="/subscribeRate"
    )
    persistence: Optional[PersistencePolicies] = Field(None, alias="persistence")
    deduplicationEnabled: Optional[bool] = Field(None, uri="/deduplication")
    autoTopicCreationOverride: Optional[AutoTopicCreationOverride] = Field(
        None, uri="/autoTopicCreation"
    )
    autoSubscriptionCreationOverride: Optional[
        AutoSubscriptionCreationOverride
    ] = Field(None, uri="/autoSubscriptionCreation")
    publishMaxMessageRate: Optional[Dict[str, PublishRate]] = None
    latencyStatsSampleRate: Optional[Dict[str, int]] = Field(
        None, alias="latency_stats_sample_rate"
    )
    messageTtlInSeconds: Optional[int] = Field(None, alias="message_ttl_in_seconds")
    subscriptionExpirationTimeMinutes: Optional[int] = Field(
        None, alias="subscription_expiration_time_minutes"
    )
    retentionPolicies: Optional[RetentionPolicies] = Field(
        None, alias="retention_policies", uri="/retention"
    )
    deleted: Optional[bool] = Field(None, alias="deleted")
    encryptionRequired: Optional[bool] = Field(None, alias="encryption_required")
    delayedDeliveryPolicies: Optional[DelayedDeliveryPolicies] = Field(
        None, alias="delayed_delivery_policies", uri="/delayedDelivery"
    )
    inactiveTopicPolicies: Optional[InactiveTopicPolicies] = Field(
        None, alias="inactive_topic_policies"
    )
    subscriptionAuthMode: Optional[SubscriptionAuthMode] = Field(
        None, alias="subscription_auth_mode"
    )
    maxProducersPerTopic: Optional[int] = Field(None, alias="max_producers_per_topic")
    maxConsumersPerTopic: Optional[int] = Field(None, alias="max_consumers_per_topic")
    maxConsumersPerSubscription: Optional[int] = Field(
        None, alias="max_consumers_per_subscription"
    )
    maxUnackedMessagesPerConsumer: Optional[int] = Field(
        None, alias="max_unacked_messages_per_consumer"
    )
    maxUnackedMessagesPerSubscription: Optional[int] = Field(
        None, alias="max_unacked_messages_per_subscription"
    )
    maxSubscriptionsPerTopic: Optional[int] = Field(
        None, alias="max_subscriptions_per_topic"
    )
    compactionThreshold: Optional[int] = Field(
        None, alias="compaction_threshold", method="PUT"
    )
    offloadThreshold: Optional[int] = Field(
        None, alias="offload_threshold", method="PUT"
    )
    offloadDeletionLagMs: Optional[int] = Field(
        None, alias="offload_deletion_lag_ms", method="PUT"
    )
    maxTopicsPerNamespace: Optional[int] = Field(None, alias="max_topics_per_namespace")
    schemaAutoUpdateCompatibilityStrategy: Optional[
        SchemaAutoUpdateCompatibilityStrategy
    ] = Field(None, alias="schema_auto_update_compatibility_strategy", method="PUT")
    schemaCompatibilityStrategy: Optional[SchemaCompatibilityStrategy] = Field(
        None, alias="schema_compatibility_strategy", method="PUT"
    )
    isAllowAutoUpdateSchema: Optional[bool] = Field(
        None, alias="is_allow_auto_update_schema"
    )
    schemaValidationEnforced: Optional[bool] = Field(
        None, alias="schema_validation_enforced"
    )
    offloadPolicies: Optional[OffloadPolicies] = Field(None, alias="offload_policies")
    deduplicationSnapshotIntervalSeconds: Optional[int] = Field(
        None, uri="/deduplicationSnapshotInterval"
    )
    subscriptionTypesEnabled: Optional[List[str]] = Field(
        None, alias="subscription_types_enabled"
    )
    properties: Optional[Dict[str, str]] = Field(None, alias="properties", method="PUT")
    resourceGroupName: Optional[str] = Field(None, alias="resource_group_name")


class TopicPolicies(BaseModel):
    class Config:
        allow_population_by_field_name = True

    deduplicationEnabled: Optional[bool] = None
    maxConsumersPerTopic: Optional[int] = Field(None, alias="max_consumers_per_topic")
    maxProducersPerTopic: Optional[int] = Field(None, alias="max_producers_per_topic")
    maxSubscriptionsPerTopic: Optional[int] = Field(
        None, alias="max_subscriptions_per_topic"
    )
    messageTtlInSeconds: Optional[int] = Field(None, alias="message_ttl_in_seconds")
    inactiveTopicPolicies: Optional[InactiveTopicPolicies] = Field(
        None, alias="inactive_topic_policies"
    )
    retentionPolicies: Optional[RetentionPolicies] = Field(
        None, alias="retention_policies", uri="/retention"
    )
    persistence: Optional[PersistencePolicies] = Field(None, alias="persistence")


class NamespaceSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    neuronClusterName: Optional[NeuronClusterName] = None
    lifecyclePolicy: Optional[LifecyclePolicy] = "KeepAfterDeletion"
    tenant: str = Field(
        ..., alias="tenant", description="Name of the tenant the namespace belongs to"
    )
    namespace: str = Field(
        ...,
        alias="namespace",
        description="Name of the namespace that should be created under the tenant",
    )
    rolePermissions: Optional[Dict[str, List[RolePermissionEnum]]] = Field(
        None, description="Sets permissions for individual roles on the namespace"
    )
    policies: Optional[NamespacePolicies] = Field(None, alias="policies")


class TopicSpec(BaseModel):
    class Config:
        allow_population_by_field_name = True

    tenant: str = Field(
        ..., alias="tenant", description="Name of the tenant the topic belongs to"
    )
    namespace: str = Field(
        ..., alias="namespace", description="Name of the namespace the topic belongs to"
    )
    topic: str = Field(
        ...,
        alias="topic",
        description="Name of the topic that should be created under the namespace and tenant",
    )
    neuronClusterName: Optional[NeuronClusterName] = None
    lifecyclePolicy: Optional[LifecyclePolicy] = "KeepAfterDeletion"
    persistent: Optional[bool] = Field(
        True, alias="persistent", description="Set persistence for the topic"
    )
    partitions: Optional[int] = Field(
        0, alias="partitions", description="Number of partitions for the topic"
    )
    rolePermissions: Optional[Dict[str, List[RolePermissionEnum]]] = Field(
        None, description="Sets permissions for individual roles on the topic"
    )
    policies: Optional[TopicPolicies] = Field(None, alias="policies")
