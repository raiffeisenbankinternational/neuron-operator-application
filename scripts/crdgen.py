import pathlib
import os
import yaml
from dollar_ref import resolve
from enum import Enum
from humps.main import is_snakecase, camelize


class MappingOperator(Enum):
    DELETE = 1


ROOT_DIR: str = str(pathlib.Path(__file__).parent.parent)
CRD_ROOT: str = f"{ROOT_DIR}/apis"
OUT_DIR: str = f"{ROOT_DIR}/crds"

try:
    os.mkdir(OUT_DIR)
except FileExistsError:
    pass

key_mapping = {
    # While this is a legal OpenAPI option, kubernetes doesn't allow it
    "uniqueItems": MappingOperator.DELETE,
}

# Some part of the OpenAPI spec is not allowed in a Kubernetes CRD here
# we recursively process all keys and delete or map once that need it.
# We also change all snake_case keys to camelCase for a nicer CRDs.
def process_keys(d: dict, mapping: dict):
    n: dict = {}
    for k, v in d.items():
        key = k
        if key in mapping and mapping[key] == MappingOperator.DELETE:
            continue
        if key in mapping and isinstance(mapping[key], str):
            key = mapping[key]

        if is_snakecase(key):
            key = camelize(key)

        if isinstance(v, dict):
            n[key] = process_keys(v, mapping)
        elif isinstance(v, list):
            n[key] = []
            for i in v:
                if isinstance(i, dict):
                    n[key].append(process_keys(i, mapping))
                else:
                    n[key].append(i)
        else:
            n[key] = v
    return n


# Loop through all files in `$project_root/apis` ending with `.ya?ml`
# and read and resolve all $ref before writing the output to `$project_root/deployment`
dir = os.fsencode(CRD_ROOT)
for file in os.listdir(dir):
    filename = os.fsdecode(file)
    if filename.endswith(".yaml") or filename.endswith(".yml"):
        print(f"Processing {filename}")
        # Read and parse file
        with open(f"{CRD_ROOT}/{filename}") as f:
            d = yaml.safe_load(f.read())
        # Resolve $ref
        resolved = resolve(d, cwd=CRD_ROOT)
        # Process some keys that need to be removed or renamed
        resolved = process_keys(resolved, key_mapping)

        # Only one version should have `served: True` and `storage: True`
        # Whatever is put first in the list will be set as served and storage
        if "spec" in resolved and "versions" in resolved["spec"]:
            vers = resolved["spec"]["versions"]
            if isinstance(vers, list) and len(vers) > 0:
                vers[0]["served"] = True
                vers[0]["storage"] = True

        # Write to new file
        with open(f"{OUT_DIR}/{filename}", "w") as f:
            f.write("# auto-generated by crdgen.py\n")
            f.write("# any changes will be over-written!\n")
            f.write("# source of truth is in neuron-operator-application/apis\n")
            f.write(yaml.dump(resolved))
